---
title: "Treinamento em Programação no Ambiente R"
date: "`r Sys.Date()`"
author: "[Statistical Genetics Laboratory](https://statgen-esalq.github.io/) <br/>  Escola Superior de Agricultura Luiz de Queiroz <br/> Universidade de São Paulo"
output:
    rmdformats::readthedown:
      css: readthedownstatgen.css
---

Esse material foi elaborado para o **Treinamento em Programação no Ambiente R**
organizado pelo Laboratório de Genetica Estatistica do Departamento de Genética da ESALQ- USP

Sugerimos que, antes de iniciar a prática aqui descrita, siga [este tutorial](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/Tutorial_instalacao.html) para instalação do R e do RStudio.


# Familiarização com a interface do RStudio

Abrindo o RStudio você verá:

<img src="imagens/Rstudio.png"  style="width:700px;height:500px;">

A interface é separada em quatro janelas com principais funções:

* Edição de código
* Ambiente de trabalho e histórico
* Console
* Arquivos, gráficos, pacotes e ajuda

Explore cada uma das janelas. São inúmeras funcionalidades para cada uma delas, veremos algumas delas ao decorrer do curso.

## Um primeiro script

A janela de edição de código (provavelmente localizada no canto superior esquerdo) você irá utilizar para escrever o seu código. Abra um novo script clicando no `+` no canto superior esquerdo e selecionando `R script`.

Vamos então iniciar os trabalhos com o tradicional `Hello World`. Digite no seu script:

```{r}
cat("Hello world")
```

Agora, selecione a linha e aperte o botão `Run` ou utilize `Ctrl + enter`.

Ao fazer isso o seu código será processado na janela `Console`, onde aparecerá em azul (se você estiver com as cores padrão do R) o código escrito e, logo em seguida, o resultado desejado. A linha somente não será processada no console se houver o símbolo `#` na frente. Agora, experimente colocar `#` na frente do código escrito. E, novamente, selecione a linha e aperte `Run`. 

```{r}
# cat("Hello world")
```

O símbolo `#` é muito utilizado para realizar **comentários** ao decorrer do código. Esta é uma ótima prática para deixar o código organizado e para que você possa lembrar mais tarde o que você estava pensando quando o escreveu ou para que outras pessoas possam entendê-lo. Como no exemplo:

```{r}
# Iniciando os trabalhos no R
cat("Hello world")
```

**Importante**: sempre que quiser realizar alguma alteração, edite o seu script e não diretamente no console, pois tudo o que neste é escrito, não terá como ser salvo!

Para salvar seu script, você pode utilizar a aba `Files` localizada (como padrão) no canto direito inferior para procurar uma localização de sua preferência, criar uma nova pasta com o nome `CursoR`. 

<span style="color:red"> Dica: </span>

* Evite colocar espaços e pontuações no nome das pastas e arquivos, isso pode dificultar o acesso via linha de comando no R. Por exemplo, ao invés de `Curso R`, optamos por `CursoR`.

Depois, basta clicar no disquete localizado no cabeçalho do RStudio ou com `Ctrl + s` e selecionar o diretório `CursoR` criado. Scripts em R são salvos com a extensão `.R`. 

## Estabelecendo diretório de trabalho

Outra boa prática no R é deixar o script no mesmo diretório onde estão seus dados brutos (arquivos de entrada no script) e os dados processados (gráficos, tabelas, etc). Para isso, vamos fazer com que o R identifique o mesmo diretório em que você salvou o script como **diretório de trabalho**, assim ele entenderá que é dali que precisa obter os dados e para lá que também irão os resultados.

Você pode fazer isso utilizando as facilidades do RStudio, basta localizar o diretório `CursoR` pela aba `Files`, clicar em `More` e depois "Set as Working Directory". Repare que irá aparecer no console algo como:

```{r, eval=FALSE}
setwd("~/Documents/CursoR")
```

Ou seja, você pode utilizar este mesmo comando para realizar esta ação. Esta então será nossa pasta de trabalho. Quando estiver perdido/a ou para ter certeza que o diretório de trabalho foi alterado utilize:

```{r, eval=FALSE}
getwd()
```

## Facilitando a vida com `Tab`

Agora, imagine que você tem um diretório como `~/Documentos/mestrado/semestre1/disciplina_tal/aula_tal/dados_28174/analise_276182/resultados_161/`. Não é fácil lembrar todo este caminho para escrever num comando `setwd()`.

Além da facilidade da janela do RStudio, você pode utilizar a tecla `Tab` para completar o caminho para você. Experimente buscando alguma pasta no seu computador. Basta começar a digitar o caminho e apertar `Tab`, ele irá completar o nome para você! Se você tiver mais do que um arquivo com aquele início de nome, aperte duas vezes o `Tab`, ele mostrará todas as opções.

O `Tab` funciona não só para indicar caminhos, mas também para comandos e nomes de objetos. É muito comum errarmos no código por erros de digitação. Utilizar o `Tab` reduzirá significativamente esses erros.


# Operações básicas

Vamos então à linguagem! 

O R pode funcionar como uma simples **calculadora**, que utiliza a mesma sintaxe que outros programas (como o excel):

```{r, eval=FALSE}
1+1.3                 #Decimal definido com "."
2*3
2^3
4/2

sqrt(4)              #raíz quadrada
log(100, base = 10)  #logarítmo na base 10
log(100)             #logarítmo com base neperiana

```

Agora, utilize as operações básicas para solucionar expressão abaixo. Lembre-se de utilizar parênteses `()` para estabelecer prioridades nas operações.

$(\frac{13+2+1.5}{3})+ log_{4}96$

Resultado esperado:

```{r, echo=FALSE}
((13+2+1.5)/3) + log(96, base = 4)
```

Repare que, se posicionar o parênteses de forma incorreta, o código não resultará em nenhuma mensagem de erro, pois este é um erro que chamamos de **erro lógico**, ou seja, o código roda, mas não faz o que você gostaria que ele fizesse. Esse é o tipo de erro mais difícil de ser consertado. Os erros que produzem uma mensagem, seja um aviso (**warning**) ou um erro (**error**) são chamados de **erros de sintaxe**. Nesses casos, o R retornará uma mensagem para te ajudar a corrigí-los. Os **warnings** não comprometem o funcionamento do código, mas chamam a atenção para algum ponto, já os **errors** precisam necessariamente ser corrigidos para que o código rode.

Exemplo de error:

```{r, eval=FALSE}
((13+2+1,5)/3) + log(96, base = 4)
```

Você pode também esquecer de fechar algum parênteses, ou aspas, ou colchetes, ou chaves, nesses casos, o R ficará aguardando o comando para fechar o bloco de código sinalizando com um `+`:

```{r, eval=FALSE}
((13+2+1.5)/3 + log(96, base = 4)
```

Se acontecer, vá até o console e aperte ESC, que o bloco será finalizado para que você possa corrigí-lo.

Os comandos `log` e `sqrt` são duas de muitas outras funções básicas que o R possui. Funções são conjuntos de instruções organizadas para realizar uma tarefa. Para todas elas, o R possui uma descrição para auxiliar no seu uso, para acessar essa ajuda use:

```{r, eval=FALSE}
?log
```

E será aberta a descrição da função na janela `Help` do RStudio.

Se a descrição do próprio R não for suficiente para você entender como funciona a função, busque no google (de preferência em inglês). Existem diversos sites e fóruns com informações didáticas das funções do R.

## Operações com vetores

Os vetores são as estruturas mais simples trabalhadas no R. Construímos um vetor com uma sequencia numérica usando:

```{r}
c(1,3,2,5,2)
```

**MUITA ATENÇÃO**: O *c* é a função do R (*Combine Values into a Vector or List*) com a qual construímos um vetor! 

Utilizamos o simbolo `:` para criar sequências de números inteiros, como:

```{r}
1:10
```

Podemos utilizar outras funções para gerar sequências, como:

```{r}
seq(from=0, to=100, by=5)
# ou
seq(0,100,5) # Se você já souber a ordem dos argumentos da função
```

* Crie uma sequencia utilizando a função `seq` que varie de 4 a 30, com intervalos de 3 em 3.

```{r, echo=FALSE}
seq(from=4, to=30, by=3)
```

A função `rep` gera sequências com números repetidos:

```{r}
rep(3:5, 2)
```

Podemos realizar operações utilizando esses vetores:

```{r,eval=FALSE}
c(1,4,3,2)*2
c(4,2,1,5)+c(5,2,6,1)
c(4,2,1,5)*c(5,2,6,1)
```

Repare que já esta ficando cansativo digitar os mesmos números repetidamente, vamos resolver isso criando **objetos** para armazenar nossos vetores e muito mais. 

# Criando objetos

O armazenamento de informações em objetos e a possível manipulação desses faz do R uma linguagem *orientada por objetos*. Para criar um objeto basta atribuir valores para as variáveis, como a seguir:

```{r, results='hide'}
x = c(30.1,30.4,40,30.2,30.6,40.1)
# ou
x <- c(30.1,30.4,40,30.2,30.6,40.1)

y = c(0.26,0.3,0.36,0.24,0.27,0.35)
```

Os mais antigos costumam usar o sinal `<-`, mas tem a mesma função de `=`. Há quem prefira usar o `<-` como atribuição em objetos e `=` apenas para definir os argumentos dentro de funções. Organize-se da forma como preferir.

Para acessar os valores dentro do objeto basta:

```{r}
x
```

A linguagem é sensível à letras maiúsculas e minúsculas, portanto `x` é diferente de `X`:

```{r, eval=FALSE}
X
```

O objeto `X` não foi criado. 

O nome dos objetos é uma escolha pessoal, a sugestão é tentar manter um padrão para melhor organização. Alguns nomes não podem ser usados por estabelecerem papéis fixos no R, são eles:

* NA - Not available, simboliza dados faltantes
* NaN - Not a number, simboliza indefinições matemáticas
* Inf - Infinite, conceito matemático
* NULL - Null object, simboliza ausência de informação

Podemos então realizar as operações com o objeto criado:

Para realizar a operação o R alinha os dois vetores e realiza a operação elemento à elemento. Observe:

```{r}
x + y
x*y
```

Se os vetores tiverem tamanhos diferentes, ele irá repetir o menor para realizar a operação elemento à elemento com todos do maior.

```{r, results='hide'}
x*2
x*c(1,2)
```

Se caso o menor vetor não for múltiplo do maior, obteremos um aviso:

```{r}
x*c(1,2,3,4)
```

Repare que o **warning** não compromente o funcionamento do código, ele só dá uma dica de que algo pode não estar da forma como você gostaria.

Podemos também armazenar a operação em outro objeto:

```{r, results='hide'}
z <- (x+y)/2
z
```

Podemos também aplicar algumas funções, como exemplo:

```{r}
sum(z)  # soma dos valores de z
mean(z) # média 
var(z)  # variância
```

## Indexação

Acessamos somente o 3º valor do vetor criado com `[]`:

```{r, results='hide'}
z[3]
```

Também podemos acessar o número da posição 2 a 4 com:

```{r}
z[2:4]
```

Para obter informações do vetor criado utilize:

```{r}
str(z)
```

A função `str` nos diz sobre a estrutura do vetor, que se trata de um vetor **numérico** com 6 elementos. 

Os vetores também podem receber outras categorias como **caracteres**:

```{r}
clone <- c("GRA02", "URO01", "URO03", "GRA02", "GRA01", "URO01")
```

Outra classe são os **fatores**, esses podem ser um pouco complexos de lidar.

De forma geral, fatores são valores categorizados por `levels`, como exemplo, se transformarmos nosso vetor de caracteres `clone` em fator, serão atribuidos níveis para cada uma das palavras:

```{r}
clone_fator <- as.factor(clone)
str(clone_fator)
levels(clone_fator)
```

Dessa forma, teremos apenas 4 níveis para um vetor com 6 elementos, já que as palavras "GRA02" e "URO01" se repetem. Podemos obter o número de elementos do vetor ou o seu comprimento com:

```{r}
length(clone_fator)
```

Também há vetores **lógicos**, que recebem valores de verdadeiro ou falso:

```{r}
logico <- x > 40
logico   # Os elementos são maiores que 40?
```

Com ele podemos, por exemplo, identificar quais são as posições dos elementos maiores que 40:

```{r}
which(logico)  # Obtendo as posiçoes dos elementos TRUE

x[which(logico)] # Obtendo os números maiores que 40 do vetor x pela posição
# ou
x[which(x > 40)]
```

Também podemos localizar elementos específicos com:

```{r}
clone %in% c("URO03", "GRA02")
```

Também podem ser úteis as funções `any` e `all`. Procure sobre elas.

Encontre mais sobre outros operadores lógicos, como o `>` utilizado, neste [link](http://www.statmethods.net/management/operators.html).

**Warning1**

Faça uma sequência numérica, contendo 10 valores inteiros, e salve em um objeto chamado "a".

```{r}
(a <- 1:10)
```

Crie outra sequência, utilizando números decimais e qualquer operação matemática, de tal forma que seus valores sejam idênticos ao objeto "a".

```{r}
b <- seq(from = 0.1, to = 1, 0.1)
(b <- b*10)
```

Os dois vetores parecem iguais, não?

Então, utilizando um operador lógico, vamos verificar o objeto "b" é igual ao objeto "a".

```{r}
a==b
```

Alguns valores não são iguais. Como isso é possivel?

```{r}
a==round(b)
```

**Warning2**

Não é possível misturar diferentes classes dentro de um mesmo vetor, ao tentar fazer isso repare que o R irá tentar igualar para uma única classe:

```{r}
errado <- c(TRUE, "vish", 1)
errado
```

No caso, todos os elementos foram transformados em caracter.

**Algumas Dicas**: 

* Cuidado com a prioridade das operações, na dúvida, sempre acrescente parenteses conforme seu interesse de prioridade.
* Lembre-se que, se esquecer de fechar algum `(` ou `[` ou `"`, o console do R ficará esperando você fechar indicando um `+`, nada será processado até que você digite diretamente no console um `)` ou aperte ESC.
* Cuidado para não sobrepor objetos já criados criando outros com o mesmo nome. Use, por exemplo: altura1, altura2.
* Mantenha no seu script .R somente os comandos que funcionaram e, de preferência, adicione comentários. Você pode, por exemplo, comentar dificuldades encontradas, para que você não cometa os mesmos erros mais tarde.

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 1**](exercicios.html#sessao1), se não, faça-os em outro momento e nos envie dúvidas pelo fórum.

## Matrizes

As matrizes são outra classe de objetos muito utilizadas no R, com elas podemos realizar operações de maior escala de forma automatizada.

Por serem usadas em operações, normalmente armazenamos nelas elementos numéricos. Para criar uma matriz, determinamos uma sequência de números e indicamos o número de linhas e colunas da matriz:

```{r}
X <- matrix(1:12, nrow = 6, ncol = 2)
X
```

Podemos também utilizar sequências já armazenadas em vetores para gerar uma matriz, desde que eles sejam numéricos:

```{r}
W <- matrix(c(x,y), nrow = 6, ncol =2)
W
```

Com elas podemos realizar operações matriciais:

```{r}
X*2
X*X        
X%*%t(X)          # Multiplicação matricial
```

Utilizar essas operações exige conhecimento de álgebra de matrizes, se quiser se aprofundar a respeito, o livro *Linear Models in Statistics, Rencher (2008)* possui um boa revisão à respeito. Você também pode explorar a sintaxe do R para essas operações neste [link](http://www.statmethods.net/advstats/matrix.html).

Acessamos os números internos à matriz dando as coordenadas [linha,coluna], como no exemplo:

```{r}
W[4,2] # Número posicionado na linha 4 e coluna 2
```


## Retomando...

<span style="color:red"> Paramos aqui no primeiro dia!! </span>

* Acesse [aqui](dia1.R) o script .R feito durante o primeiro dia de curso
* Acesse [aqui](dia1.Rmd) o script em Rmarkdown do que foi feito no primeiro dia de curso
* Acesse [aqui](dia1.RData) todos os objetos gerados  no primeiro dia de curso. Precisaremos de alguns deles a seguir. 

* Link mencionado: https://rpubs.com/
* [Shortcuts do RStudio](https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts)

As vezes pode ser informativo dar nomes às colunas e às linhas da matriz, fazemos isso com:

```{r}
colnames(W) <- c("altura", "diametro")
rownames(W) <- clone
W
```

Essas funções `colnames` e `rownames` também funcionam nos data.frames.

## Data.frames

Diferente das matrizes, não realizamos operações com os data.frames, mas eles permitem a união de vetores com classes diferentes. Os *data frames* são semelhantes a tabelas geradas em outros programas, como o excel.

Os *data frames* são combinações de vetores de mesmo comprimento. Todos os que criamos até agora tem tamanho 6, verifique. 

Podemos assim combiná-los em colunas de um único data.frame:

```{r}
campo1 <- data.frame("clone" = clone,     # Antes do sinal de "="  
                     "altura" = x,        # estabelecemos os nomes  
                     "diametro" = y,      # das colunas
                     "idade" = rep(3:5, 2),
                     "corte"= logico) 
campo1
```

Podemos acessar cada uma das colunas com:

```{r}
campo1$idade
```

Ou também com:

```{r}
campo1[,4] 
```

Aqui, o número dentro dos colchetes se refere à coluna, por ser o segundo elemento (separado por vírgula). O primeiro elemento se refere à linha. Como deixamos o primeiro elemento vazio, estaremos nos referindo a todas as linhas para aquela coluna.

Dessa forma, se quisermos obter um conteúdo específico podemos dar as coordenadas com [linha,coluna]:

```{r}
campo1[1,2] 
```

* Obtenha o diâmetro do clone "URO03.

```{r, echo=FALSE}
campo1[3,3] 
```

Mesmo se tratando de um *data frame*, podemos realizar operações com os vetores numéricos que a compõe.

* Com o diâmetro e a altura das árvores, calcule o volume conforme a fórmula a seguir e armazene em um objeto `volume`:

$3.14*(diametro/2)^2*altura$

```{r, echo=FALSE}
volume <- 3.14*((campo1$diametro/2)^2)*campo1$altura
volume
```

Agora, vamos adicionar o vetor calculado com o volume ao nosso data.frame. Para isso use a função `cbind`.

```{r}
campo1 <- cbind(campo1, volume)
campo1
str(campo1)
```

**Algumas dicas**:

* Lembre-se que, para construir matrizes e *data frames*, o número de elementos em cada coluna tem que ser iguais.
* Caso não saiba o operador ou a função que deve ser utilizada, como o desvio padrão, busque no google algo como "desvio padrão R", ou melhor "standard deviation R". Logo nas primeiras páginas você obterá respostas. A comunidade do R é bastante ativa e grande parte das suas perguntas sobre ele já foram respondidas em algum lugar da web.
* Não esqueça que tudo o que fizer no R precisa ser explicitamente indicado, como uma multiplicação 4ac com `4*a*c`. Para gerar um vetor 1,3,2,6 é necessário: `c(1,3,2,6)`.

## Listas

Listas consistem em uma coleção de objetos, não necessariamente de mesma classe. Nelas podemos armazenar todos os outros objetos já vistos e recuperá-los pela indexação com `[[`. Como exemplo, vamos utilizar alguns objetos que já foram gerados.

```{r}
minha_lista <- list(campo1 = campo1, media_alt = tapply(campo1$altura, campo1$idade, mean), matrix_ex = W)
str(minha_lista)
```

Quero acessar o data.frame `campo1`

```{r}
minha_lista[[1]] 
# ou
minha_lista$campo1
```
Para acessar uma coluna específica no data.frame `campo1`, que está dentro da minha_lista:  

```{r}
minha_lista[[1]][[3]]
# ou
minha_lista[[1]]$diametro
# ou
minha_lista$campo1$diametro
```

Listas são muito úteis, por exemplo, quando vamos utilizar/gerar diversos objetos dentro de um loop. 

## Arrays

Este é um tipo de objeto que você provavelmente não irá utilizar agora no início, mas é bom saber da sua existência. São utilizados para armazenar dados com mais de duas dimensões. Por exemplo, se criarmos um array:

```{r}
(meu_array <- array(1:24, dim = c(2,3,4)))
```

Teremos quatro matrizes com duas linhas e três colunas e os números de 1 a 24 estarão distribuídos nelas por colunas.

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 2**](exercicios.html#sessao2), se não, faça-os em outro momento e nos envie dúvidas pelo fórum.

* Obtenha o arquivo RData com todos os objetos criados até então no tutorial [aqui](https://GENt-esalq.github.io/cursoR2/dia1.RData).

**Coloque ambos no seu Diretório de Trabalho**

# Importando e exportando dados

Os arquivos RData são exclusivos do R, clicando duas vezes no arquivo ou utilizando:

```{r}
load("dia1.RData")
```

Você vai recuperar todos os objetos gerados até agora no tutorial. Para gerar esse arquivo RData, eu rodei todos os códigos daqui para cima e usei:

```{r}
save.image(file = "dia1.RData")
```

Este comando salva tudo o que você tem no seu Ambiente Global (todos os objetos que aparecem ali no canto direito superior). Você pode também salvar somente um objeto com:

```{r, eval=FALSE}
save(campo1, file = "campo1.RData")
```

Se removermos ele do nosso Ambiente Global com:

```{r, eval=FALSE}
rm(campo1)  # Certifique-se que salvou o arquivo RData antes de removê-lo
```

Podemos facilmente obtê-lo novamente com:

```{r, eval=FALSE}
load("campo1.RData")
```

O formato RData é exclusivo para o R, ele é interessante de ser usado para fazer o que estamos fazendo, paramos a análise em um dia, vamos continuar em um outro e não queremos ter que rodar tudo de novo. Mas muitas vezes precisamos exportar nossos dados para outros programas, que exigem outros formatos, como, por exemplo, `.txt` ou `.csv`. Para isso utilizamos:

```{r, eval=FALSE}
write.table(campo1, file = "campo1.txt", sep = ";", dec = ".", row.names = FALSE)
write.csv(campo1, file = "campo1.csv", row.names = TRUE)
```

Obs: Você pode adquirir pacotes para exportar e importar dados com outros fomatos, como exemplo o pacote `xlsx` exporta e importa dados com formato do excel. O pacote `vroom` pode ser utilizado para compactar grandes tabelas.

Ao exportar, há diversas opções para a formatação do arquivo, é importante considerá-las se o arquivo for usado em outro sofware posteriormente.

Abra os arquivos gerados para visualizar sua formatação.

Esses arquivos podem ser lidos novamente pelo R, utilizando as funções e suas especificações:

```{r, eval=FALSE}
campo1_txt <- read.table(file = "campo1.txt", sep=";", dec=".", header = TRUE)
campo1_csv <- read.csv(file = "campo1.csv")
head(campo1_txt)
head(campo1_csv)
```

Agora que aprendemos a importar dados, vamos trabalhar com o conjunto gerado a partir dos participantes da disciplina Biometria de Marcadores - Turma de 2021.

<span style="color:red">
A planilha com os dados está disponível no link abaixo, adicione-a ao seu diretório de trabalho ou indique o caminho da pasta ao importá-la para dentro do R, como a seguir. </span> 

* [dados.RData](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/dados_alunos2021.RData) 
* [dados.csv](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/dados_alunos2021.csv)

Aqui usaremos o argumento `stringAsFactors` que impede que o R transforme os vetores da tabela em fatores, os quais são mais difíceis de trabalhar. O argumento `na.strings` irá indicar como foram nomeados os dados perdidos.

```{r, eval=FALSE}
dados <- read.csv(file = "dados_alunos2021.csv", stringsAsFactors = FALSE, na.strings="-", header = T, dec = ",")
head(dados)
```

```{r}
load("dados_alunos2021.RData")
```

Vamos explorar a estrutura dos dados coletados:

```{r}
str(dados)
# também
dim(dados)
```

Repare que nos nomes das colunas ainda estão as perguntas completas feitas no formulário, vamos alterar para nomes mais fáceis de trabalhar:

```{r}
colnames(dados)

colnames(dados) = c("Ocupacao", "Graduacao", "Conhecimentos_Genetica", "Conhecimentos_Estatistica", "Conhecimento_Gen_Est", 
                   "Latitude", "Longitude")
colnames(dados)
str(dados)
```

# Manipulando os dados

Agora usaremos os dados que temos para aprender diferentes comandos e funções do Ambiente R.

Primeiro, vamos verificar quantos alunos responderam as questões do formulario da disciplina, contando o número de linhas, para isso use a função `nrow`.

```{r}
nrow(dados)
```

Vamos então verificar se temos no nosso grupo pessoas que compartilham a mesma graduação e ocupação.

Podemos verificar isso facilmente com a função `table`, que indica a frequência de cada observação:
 
```{r, eval=FALSE}
table(dados$Graduacao)
table(dados$Ocupacao)
```

# Estruturas condicionais

## if e else

Para nossa próxima atividade com os dados, vamos primeiro entender como funcionam as estruturas `if` e `else`.

Nas funções condicionais `if` e `else`, estabelecemos uma condição para if, se ela for verdade a atividade será realizada, caso contrário (else) outra tarefa será. Como no exemplo:

```{r}
if(2 >3){
  cat("dois é maior que três")
} else {
  cat("dois não é maior que três")
}
```

* Descubra a Nivel de Conhecimentos em Genetica (3ª coluna) da segunda pessoa que o respondeu (linha 2). Envie uma mensagem motivacional se ela possuir conhecimentos basicos, outra se a pessoa ja possuir conhecimento Intermediario ou Avançado (restante das respostas). (dica: o sinal `==` se refere a "exatamente igual a")

```{r}
if(dados[2,3] =="Básico"){
  cat("Força, Mendel acredita em você!")
} else {
  cat("Mendel agradece a preferência")
}
```

Podemos espeficiar mais do que uma condição repetindo a estrutura `if` `else`:
Agora vamos estudar a ocupação das pessoas que responderam ao questionário.

```{r}
if(dados[2,1] == "Mestrado"){
  cat("Força, o quinto dia útil esta chegando!")
} else if (dados[2,1] == "Doutorado"){
  cat("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
} else {
  cat("Esse já tem a carteira assinada, que beleza!")
}
```

Também podemos fazer uso das funções `any` e `all`. Lembrando como `any` e `all` funcionam:

```{r}
x <- 1:10
x
all(x > 0)
any(x > 0)

all(x > 9)
any(x > 9)

all(x > 10)
any(x > 10)
```

Podemos utilizar essas funções para testar se alguém de nós mora no centro de Piracicaba:

```{r, eval=FALSE}
range(dados$Latitude)

if(any(dados[,6] ==  -22.725)){
  cat("Alguem mora no centro de Piracicaba")
} else{
  cat("Ninguem mora no centro de Piracicaba.")
}

if(all(dados[,6] ==  -22.725)){
  cat("Todos moram no Centro de Piracicaba.")
} else{
  cat("Nem todos moram no centro de Piracicaba")
}
```

Usando a mesma lógica: será que algum de nós está no hemisfério norte do globo (latitude 6ª coluna maior que 0)? Se sim, diga para essa pessoa testar o sentido que a água do vaso sanitário gira.

```{r}
if(any(dados[,6] > 0)){
  cat("Participantes", which(dados[,6] > 0), "vocês podem testar em que sentido a água do vaso sanitário gira aí?")
} 
```

## Switch

Uma outra estrutura que também pode ser usada com o mesmo propósito é o `switch`. Esta estrutura é mais utilizada quando trabalhado com caracteres. Por isso vamos aplicá-la também para a ocupação para vermos como pode ser mais simples (1ª coluna) o que a segunda e a quarta pessoa fazem.

```{r}
switch(dados[2,1],
  Mestrado = cat("Força, o quinto dia util esta chegando!"),
  Doutorado = cat("Assim como seus amigos do mestrado, acredite ate sexta a bolsa cai!"),
  cat("Esse ja tem a carteira assinada, que beleza!")
)
switch(dados[4,1],
  Mestrado = cat("Força, o quinto dia util esta chegando!"),
  Doutorado = cat("Assim como seus amigos do mestrado, acredite ate sexta a bolsa cai!"),
  cat("Esse ja tem a carteira assinada, que beleza!")
)

```

A estrutura `switch` costuma ser mais rápida que o `if` e `else`. Quando lidamos com grande quantidade de dados isso pode ser uma grande vantagem.

Mas repare que só é possível utilizar essas estruturas para um elemento individual do vetor ou em todo ele, se quisermos percorrer os elementos individualmente precisamos recorrer a outro recurso.

# Estruturas de repetição

## For

Esse recurso pode ser a função `for`, uma função muito utilizada e poderosa. Ela constitui uma estrutura de loop, pois irá aplicar a mesma atividade repetidamente até atingir uma determinada condição. Veja exemplos:

```{r}
for(i in 1:10){
  print(i)
}

test <- vector()
for(i in 1:10){
  test[i] <- i+4 
}
test
```

Nos casos acima, `i` funciona como um índice que irá variar de 1 até 10 a operação determinada entre chaves.

Com essa estrutura, podemos repetir a operação realizada com as estruturas `if` e `else` para todo o vetor:

```{r, eval=F}
for(i in 1:nrow(dados)){
  if(dados[i,1] == "Mestrado"){
    print("Força, o quinto dia útil esta chegando!")
  } else if (dados[i,1] == "Doutorado"){
    print("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
  } else {
    print("Esse já tem a carteira assinada, que beleza!")
  }
}
```

**Dica: Identação**

Repare a diferença:

```{r, eval=FALSE}
# Sem identação
for(i in 1:nrow(dados)){
if(dados[i,1] == "Mestrado"){
print("Força, o quinto dia útil esta chegando!")
} else if (dados[i,1] == "Doutorado"){
print("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
} else {
print("Esse já tem a carteira assinada, que beleza!")
}
}

# Com identação correta
for(i in 1:nrow(dados)){
  if(dados[i,1] == "Mestrado"){
    print("Força, o quinto dia útil esta chegando!")
  } else if (dados[i,1] == "Doutorado"){
    print("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
  } else {
    print("Esse já tem a carteira assinada, que beleza!")
  }
}
```

O editor de código do RStudio tem uma facilitação para identar códigos em R, selecione a área que deseja identar e aperte `Ctrl-i`.

Agora vamos trabalhar com a coluna 2, que possui a informação da graduação dos participantes. Repare que a função `table` retorna diferentes categorias que poderiam ser resumidas em apenas uma, como  "Engenharia agronômica" e "Agronomia". Vamos utilizar um loop para descobrir quais responderam áreas relacionadas à "Agro". Depois, quais dessas respostas não foram "Agronomia" e pedir para que este participante modifique a resposta digitando apenas "Agronomia". 

Dica 1: Para identificar o padrão "Agro" podemos utilizar  a função `grepl`.
Dica 2: Podemos utilizar if dentro de if

```{r}
# Exemplo do uso da função grepl
dados[,2]
grepl("Agro", dados[,2]) # Quais linhas contém os caracteres "Agro"
dados[grepl("Agro", dados[,2]),2]

for(i in 1:nrow(dados)){
  if(grepl("Agro", dados[i,2])){
    if(dados[i,2] != "Agronomia"){
     print("Por favor, substitua sua resposta por Agronomia.") 
    }
  } 
}
```

Para que seja possível imprimir conteúdo de objetos durante o loop, usamos a função `cat`, ela não separa cada resposta em uma linha, precisamos colocar o `\n` indicando a quebra de linha.

Agora vamos nos mesmos homogeneizar essas informações. Podemos armazenar em uma variável a posição das linhas identificadas, então corrigiremos manualmente somente essas:

```{r}
homog <- vector()
for(i in 1:nrow(dados)){
  if(grepl("Agro", dados[i,2])){
    if(dados[i,2] != "Agronomia"){
     print("Por favor, substitua sua resposta por Agronomia.") 
     homog <- c(homog, i)
    }
  } 
}

homog
```

> Como você faria para corrigir esses elementos errados? Tente!

['dados[homog, 2] <- "Agronomia"']{.spoiler}

## While

Nesse tipo de estrutura de repetição a tarefa será realizada até que seja atingida determinada condição.

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  cat(x)
}
```

É muito importante que nessa estrutura a condição seja atingida, caso contrário o loop irá funcionar infinitamente e você terá que interrompê-lo por meios externos, como, se este utilizando RStudio, clicar no simbolo em vermelho no canto direito superior da janela do console, ou apertar Ctrl+C no console.

Não é muito difícil disso acontecer, basta um pequeno erro como:

```{r, eval=FALSE}
x <- 1

while(x < 5){
  x + 1
  cat(x)
}
```

Aqui podemos utilizar os comandos `break` e `next` para atender a outras condições, como:

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) break
  cat(x)
}

x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) next
  cat(x)
}

```

## Repeat

Esta estrutura também exige uma condição de parada, mas esta condição é necessariamente colocada dentro do bloco de código com o uso do `break`. Ela então repete o bloco de código até a condição o interrompa.

```{r}
x <- 1
repeat{
  x <- x+1
  cat(x)
  if(x==4) break
}

```

## Loops dentro de loops

É possível também utilizarmos estruturas de repetição dentro de estruturas de repetição. Por exemplo, se quisermos trabalhar tanto nas colunas como nas linhas de uma matrix.

```{r}
# Criando uma matrix vazia
ex_mat <- matrix(nrow=10, ncol=10)

# cada número dentro da matrix será o produto no índice da coluna pelo índice da linha
for(i in 1:dim(ex_mat)[1]) {
  for(j in 1:dim(ex_mat)[2]) {
    ex_mat[i,j] = i*j
  }
}

```

Outro exemplo de uso:

```{r}
var1 <- c("fertilizante1", "fertilizante2")
var2 <- c("ESS", "URO", "GRA")

w <- 1
for(i in var1){
  for(j in var2){
    nome_arquivo <- paste0(i,"_planta_",j,".txt")
    arquivo <- data.frame("bloco" = "fake_data", "tratamento" ="fake_data")
    write.table(arquivo, file = nome_arquivo)
    w <- w + 1
  }
}

# Verifique seu diretorio de trabalho, arquivos devem ter sido gerados
```

Fizemos um vídeo com mais detalhes sobre loops no R (quando cursamos a disciplina de Biometria de Marcadores), aumentem nossa quantidade de views e likes por [lá](https://www.youtube.com/watch?v=VYOo7I5htOw).

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 3**](exercicios.html#sessao3), se não, faça-os em outro momento e nos envie dúvidas pelo fórum.

**Algumas dicas**:

* Cuidado ao rodar o mesmo comando mais de uma vez, algumas variáveis podem não ser mais como eram antes. Para que o comando funcione da mesma forma é necessário que os objetos de entrada estejam da forma como você espera.
* Lembrem-se que `=` é para definir objetos e `==` é o sinal de igualdade. 
* Nas estruturas condicionais e de repetição, lembrem-se que é necessário manter a sintaxe esperada: If(){} e for(i in 1:10){}. No *for*, podemos trocar a letra que será o índice, mas é sempre necessário fornecer uma sequência de inteiros ou caracteres.
* Usar identação ajuda a visualizar o começo e fim de cada estrutura de código e facilita o abrir e fechar de chaves. Identação são aqueles espaços que usamos antes da linha, como:

```{r}
# Criando uma matrix vazia
ex_mat <- matrix(nrow=10, ncol=10)

# cada número dentro da matrix será o produto no índice da coluna pelo índice da linha
for(i in 1:dim(ex_mat)[1]) {   # Primeiro nível, não tem espaço
  for(j in 1:dim(ex_mat)[2]) { # Segundo nível tem um espaço (tab)
    ex_mat[i,j] = i*j          # Terceiro nível tem dois espaços
  }                            # Fechei o segundo nível
}                              # Fechei o primeiro nível

```


# Elaboração de funções

Normalmente é uma boa prática criar um bloco de código se vai realizar aquela ação poucas vezes. Se for realizar várias vezes a ação e de uma vez só, vale a pena fazer um loop. Mas, se for realizar diversas vezes e o objeto de entrada for modificado, vale a pena fazer uma função. E, na hierarquia, quando tiver acumulado muitas funções para realizar uma tarefa mais complexa, vale a pena construir um pacote.

A função também é considerada um objeto no R, portanto você a atribui à uma variável. Procure nomear a função com um nome curto e intuitivo em relação à tarefa que ela executa. Essa nem sempre é uma tarefa fácil.

<img src="meme.png" alt="[referência](https://www.reddit.com/r/ProgrammerHumor/comments/5z6n8p/every_time/)" width="300" height="400">


Para criar uma função obedeça a seguinte estrutura:

```
nome_da_funcao <- function(argumento1, argumento2,...){
  corpo da função
}
```  

Como exemplo, vamos criar a função `quadra`. Estabelecemos os argumentos da função, nesse caso `x`. Entre as chaves fica todo o corpo da função. Se você quer que a função retorne algum valor, é necessário utilizar o `return`.

```{r}
quadra <- function(x){
  z <- x*x
  return(z)
}

quadra(3)
quadra(4)

qualquer_nome <- 4
quadra(qualquer_nome)
```

O ambiente de variáveis utilizado pela função é diferente do ambiente global em que são armazenadas todos as variáveis já criadas. Variáveis criadas no corpo da função não pertencerão ao ambiente global, mas as contidas no ambiente global podem ser acessadas pela função. Observe:

```{r, eval=FALSE}
rm(z) # certificando que não há uma variável/objeto z criada/o

# Na função quadra, criamos uma variável z internamente
quadra(qualquer_nome)
z # mais ele não é criado no ambiente global, só no ambiente interno da função, e z desaparece assim que a função termina sua tarefa
```

Agora vamos criar uma outra funçao que usa `y`, mas não possui `y` como argumento. **Atenção**: não façam isso na rotina de vocês, sempre estabeleçam tudo o que for ser usado no corpo da função nos argumentos dela, estamos fazendo aqui apenas para fins didádicos.

```{r, eval=FALSE}
rm(y)
quadra_mais_y <- function(x){
  z <- x*x + y
  return(z)
}

quadra_mais_y(4) # não temos ainda y

y <- 2

quadra_mais_y(4) # quando temos, a função acessa o y do ambiente global
```

Agora, vamos criar uma função para indicar quais participantes estão no hemisfério sul/norte e à oriente/ocidente do meridiano de Greenwich. Lembrando que latitudes > 0 se referem ao hemisfério norte e longitudes > 0 ao hemisfério oriental.

```{r}
localizacao <- function(latitude, longitude){
  hemisferio <- vector()
  hemisferio[which(latitude > 0)] <- "Norte"
  hemisferio[which(latitude < 0)] <- "Sul"
  hemisferio[which(latitude == 0)] <- "Equador"
  
  meridiano <- vector()
  meridiano[which(longitude > 0)] <- "Oriente"
  meridiano[which(longitude < 0)] <- "Ocidente"
  meridiano[which(longitude == 0)] <- "Meridiano de Greenwich"
  
  df <- data.frame(hemisferio, meridiano)
  return(df)
}

localizacao(latitude = dados[,6], longitude = dados[,7])
```

Agora, aprimore a função acima adicionando também uma coluna que indique a média de conhecimento do participante sobre as três áreas perguntadas. Considere para isso: Básico = 1, Intermediário = 2, Avançado = 3, Sabe o teste F? Fui eu que desenvolvi, mas não publiquei porque sou modesto = 99 e 0 = 0.

```{r}
# Dica
dados[dados == "Avançado"] <- 3
dados[dados == "Intermediário"] <- 2
dados[dados == "Básico"] <- 1
dados[dados == "Sabe o teste F? Fui eu que desenvolvi, mas não publiquei porque sou modesto"] <- 99
```


```{r}
localizacao <- function(latitude, 
                        longitude, 
                        genetica, 
                        estatistica, 
                        genetica_estatistica){
  hemisferio <- vector()
  hemisferio[which(latitude > 0)] <- "Norte"
  hemisferio[which(latitude < 0)] <- "Sul"
  hemisferio[which(latitude == 0)] <- "Equador"
  
  meridiano <- vector()
  meridiano[which(longitude > 0)] <- "Oriente"
  meridiano[which(longitude < 0)] <- "Ocidente"
  meridiano[which(longitude == 0)] <- "Meridiano de Greenwich"
  
  medias <- (as.numeric(genetica) + 
             as.numeric(estatistica) + 
             as.numeric(genetica_estatistica))/3
  
  df <- data.frame(hemisferio, meridiano, round(medias,2))
  return(df)
}

localizacao(dados[,6], dados[,7], genetica = dados[,3], 
            estatistica = dados[,4], genetica_estatistica = dados[,5])
```

Se é uma função para uso próprio, você saberá como deve ser o objeto de entrada, mas se ela for utilizada por outras pessoas, será necessário, além de uma prévia explicação de suas ações, verificar se o objeto de entrada esta de acordo com o esperado pela função. No nosso exemplo, não faria sentido o usário entrar com números fora do intervalo [-180, 180]. Faça com que a função retorne um erro caso isso aconteça.

```{r}
localizacao <- function(latitude, 
                        longitude, 
                        genetica, 
                        estatistica, 
                        genetica_estatistica){
  
  if(any(latitude < -180 | latitude > 180)) stop("Valores de latitude inválidos")
  if(any(longitude < -180 | longitude > 180)) stop("Valores de longitude inválidos")
  
  hemisferio <- vector()
  hemisferio[which(latitude > 0)] <- "Norte"
  hemisferio[which(latitude < 0)] <- "Sul"
  hemisferio[which(latitude == 0)] <- "Equador"
  
  meridiano <- vector()
  meridiano[which(longitude > 0)] <- "Oriente"
  meridiano[which(longitude < 0)] <- "Ocidente"
  meridiano[which(longitude == 0)] <- "Meridiano de Greenwich"
  
  medias <- (as.numeric(genetica) + 
             as.numeric(estatistica) + 
             as.numeric(genetica_estatistica))/3
  
  df <- data.frame(hemisferio, meridiano, round(medias,2))
  return(df)
}

localizacao(dados[,6], dados[,7], genetica = dados[,3], 
            estatistica = dados[,4], genetica_estatistica = dados[,5])
```

Para saber mais sobre desenvolvimento de funções acesse [aqui](https://www.r-bloggers.com/how-to-write-and-debug-an-r-function/) e, um pouco mais avançado, [aqui](http://adv-r.had.co.nz/Functions.html).

# Rodando outros scripts .R 

As vezes, parte do seu código demanda que você chame algo que foi rodado em outro script. Muitas pessoas também tem o costume de salvar as funções próprias em um script separado. Vamos fazer isso? 

* Abra um novo script .R, copie suas funções para ele e o salve como `funcoes.R`

Agora, você pode acessa-las usando:

```{r, eval=FALSE}
source("funcoes.R")
```


> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 4**](exercicios.html#sessao4), se não, faça-os em outro momento e nos envie dúvidas pelo fórum.

# Elaboração de gráficos simples

Para outros dados coletados, vamos gerar alguns gráficos simples utilizando as funções básicas do R. Existem pacotes como o `ggplot2`, `plotly` e `shiny` que possuem ferramentas muito poderosas para construção de gráficos, mas exigem um pouco mais de tempo para aprendizagem de sua sintaxe.

Os tipos mais comuns já possuem funções próprias, mas outros gráficos podem ser customizados de acordo com a necessidade do usuário. Vamos iniciar com um simples gráfico de frequências (ou histograma) para os dados de `latitude`.

```{r}
hist(dados$Latitude)
```

Vamos adicionar alguns argumentos para dar uma personalizada:

* `breaks` para definir os intervalos para cada barra; 

```{r, echo=FALSE}
#### Histograma ####
#Utiliza um vetor de valores para obter as frequências
hist(dados$Latitude)
hist(dados$Latitude, breaks = 2)
hist(dados$Latitude, breaks = 15) 

```

Agora tente fazer o **histograma para a Longitude**, aproveite para tentar alterar alguns parâmetros. Em seguida, serão apresentados outros gráficos que poderão ser utilizados.

## Salvar gráficos

Os gráficos podem ser salvos através dos menus disponíveis no RStudio, ou através de funções que permitem salvar em formatos específicos. Algumas delas são: pdf(); png(); jpeg(); bitmap(). De maneira geral, o parâmetro primordial é fornecer o nome do arquivo que será gerado (contendo sua extensão). Após abrir a função gráfica, deve-se gerar o gráfico de interesse. Por fim, utiliza-se o comando dev.off() para que saída gráfica volte para o console.

```{r eval=FALSE}
png(filename = "hist_rbase.png")
hist(dados$Latitude)
dev.off()

png(filename = "hist_rbase.png", width = 1500, height = 1500, res= 300)
hist(dados$Latitude)
dev.off()
```

Agora, gere um gráfico e salve-o no formato de seu interesse. Em seguida, crie diversos gráficos dentro de uma mesma função gráfica e estude a saída. 

# Aplicações de pacotes

Existem diversos pacotes disponíveis para variadas aplicações. Utilizaremos o *ggplot2*, que está disponível no repositório oficial do R, o CRAN. Portanto para instalá-lo:

```{r eval=FALSE}
install.packages("ggplot2")
```

Depois disso é necessário recrutá-lo toda vez que iniciar um sessão no R:

```{r}
library("ggplot2")
```

O `ggplot2` é um pacote que permite a construção de gráficos estatísticos, suas funcionalidades vão muito além do que está disponível nos gráficos básicos do R. 


# Pratique gerando relatórios no RStudio
 
 Utilize o R no seu dia-a-dia para ir praticando a linguagem. Além das recomendações contidas na [primeira apresentação](), recomendamos também dar uma olhada em como gerar documentos em pdf e html usando a Markdown. Utilizamos essa metodologia para gerar este tutorial e outras apresentações do curso. Pode ser muito prático no dia-a-dia!
 
Para utilizar, será necessário a instalação de outros pacotes. Um deles é o próprio `rmarkdown`:

```{r, eval=FALSE}
install.packages("rmarkdown")
```

```{r}
library(rmarkdown)
```
 
Agora crie um arquivo .Rmd utilizando as facilidades do RStudio, clique no ícone com símbolo `+` no canto superior esquerdo. Escolha o opção `R Markdown`. Dê um título ao seu arquivo e escolha a opção `html`. Ao fazer isso, o RStudio já coloca um template inicial, ja com um cabeçalho:

```
---
title: "Teste"
author: "Eu"
date: "June 5, 2018"
output: html_document
---

```

Este é o mais simples possível, você pode otimizá-lo de diversas maneiras. Saiba mais [aqui](https://rmarkdown.rstudio.com/html_document_format.html).

O template inicial também traz alguns exemplos de sintaxe do markdown. Observe que utilizando `#` para títulos de sessões, `##` para um nível inferior (subtitulos) e assim por diante. Palavras em negrito são escritas em meia a dois `*` e existem diversas outras especificações para essa sintaxe. Veja mais sobre ela [aqui](https://www.markdownguide.org/basic-syntax).

Para compilar o código, basta clicar em `Knit`. Ele irá pedir para que o arquivo .Rmd seja salvo com algum nome em algum lugar.

O markdown também é capaz de entender diretamente a linguagem html, também a css e latex. Para essa última, o latex precisa estar instalado e todas suas dependências.

Existem alguns pacotes que fornecem templates mais robustos para produção de htmls. Para esse tutorial utilizando o pacote `rmdformats` e personalizamos suas cores. Experimente:

```{r, eval=FALSE}
install.packages("rmdformats")
```

Agora faça o mesmo procedimento, clique no `+`, escolha `R Markdown` e, antes de escolher um título, mude para `From Template`, escolha o `HTML readthedown template`. Copie e cole o seguinte texto e aperte `Knit`.

```
# Teste1

Isso aqui é um teste só para dar uma olhada no template

## Testinho

Subsessão

* Item

**negrito**

*itálico*

fiz um [link](https://GENt-esalq.github.io/)!

```


Saiba mais no tutorial do R-bloggers, que acreditamos ser um bom começo! Acesse [aqui](https://www.r-bloggers.com/how-to-create-reports-with-r-markdown-in-rstudio/).

# Extra

## Algumas ferramentas básicas de análise de dados

Claramente a análise de dados é algo muito específico de cada conjunto de dados e interesses, aqui apenas exemplificaremos o uso de algumas funções do R em duas situações específicas.

### Avaliando o clima de Londrina

Vamos utilizar outro conjunto de dados para realizarmos mais avaliações utilizando a função `lm`. Acesse o conjunto [clima_lond](clima_lond.RData):

```{r}
load("clima_lond.RData")
```

Para obter os dados de precipitação da cidade de Londrina no primeiro semestre de 2017. Vamos utilizar as funções `tapply` e
`lm` para avaliar os dados.

Algumas avaliações descritivas podem ser feitas pelo uso do `tapply` e de gráficos. A função `summary` também fornece informações gerais do conjunto. É possível usá-la em conjunto com o `tapply`.

```{r}
# Verificando se as variáveis categórias estão como fatores
str(clima_lond)

clima_lond$dia <- as.factor(clima_lond$dia)

# A precipitação nesse caso é uma variável contínua, nao categórica, para transformá-la use:

clima_lond$prec.mm <- as.numeric(as.character(clima_lond$prec.mm))

# Já com o tapply podemos ver as diferenças

tapply(clima_lond$prec.mm, clima_lond$Mes, summary)
```

Repare que os níveis aparecem em ordem alfabética e não conforme o tempo, alteramos isso com:

```{r}
levels(clima_lond$Mes)

# A função match vai indicar a posição dos elementos do primeiro vetor no segundo vetor
pos <- match(c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho"), levels(clima_lond$Mes))
pos

# Aqui utilizamos as posições obtidas para reordenar os meses nos níveis do fator
clima_lond$Mes = factor(clima_lond$Mes,
                       levels(clima_lond$Mes)[pos])

# Refazendo
tapply(clima_lond$prec.mm, clima_lond$Mes, summary)

```

Podemos também avaliar visualmente através de gráficos:

```{r}
ggplot(clima_lond) + 
  geom_point(aes(x = Mes, y = prec.mm)) +
  labs(title = "Precipitação x Mês", x = "Meses do ano de 2017", y = "Precipitação em mm")
```

```{r}
barplot(tapply(clima_lond$prec.mm, clima_lond$Mes, sum), 
        main="Total Mensal",
        xlab = "Meses do ano de 2017",
        ylab = "Precipitação em mm")

# Vamos fazer um gráfico de barras que mostre a soma de precipitação em cada mês
stat_lond <- tapply(clima_lond$prec.mm, clima_lond$Mes, sum)
str(stat_lond)

# Repare que o resultado do tapply é um vetor com seus elementos nomeados com cada mês
# Para usar o ggplot nesse caso, precisamos elaborar um data.frame cujas colunas sejam as variáveis que utilizaremos
stat_lond_edit <- data.frame("mes" = factor(names(stat_lond), 
                                            levels = c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho")), "soma" = stat_lond)
str(stat_lond_edit)

ggplot(stat_lond_edit) +
  geom_bar(aes(x = mes, y = soma), stat="identity") +
  labs(title= "Soma da precipitação por mês", x = "Meses do ano de 2017", y = "Soma da precipitação")

```

Vamos então realizar uma análise de variância a fim de verificar se há diferenças significativas entre os meses. As funções `lm` e `summary` diferem apenas na forma de apresentar os resultados. O p-valor nos indica se podemos considerar diferenças do peso conforme o gênero.

```{r}
mod <- lm(prec.mm ~ Mes, data = clima_lond)
summary(mod)

modaov <- aov(prec.mm ~ Mes, data = clima_lond)
summary(modaov)
```

Podemos também fazer um teste de médias para diferenciar a precipitação no decorrer dos meses. Aqui utilizaremos o método de Tukey:

```{r}
tukey.test <- TukeyHSD(x=modaov, 'Mes', conf.level=0.95)
tukey.test
```

### Avaliando experimento de café

Agora, trabalharemos com dados de um experimento de café. Acesse aqui:

* Arquivo [cafe.txt](https://GENt-esalq.github.io/cursoR2/cafe.txt)

O experimento trata-se de dados em blocos completos casualizados de 10 progênies de café. Nele a coluna `rep` refere-se à repetição, `prog` indica o indivíduo da progênie (prog) e `colheita` indica a colheita.

```{r}
data <- read.table("cafe.txt", h = TRUE, sep = "\t", dec = ",")
str(data)
```

**Não esqueça que é necessário que o arquivo esteja no seu ambiente de trabalho ou que você especifique o caminho completo para que o R o encontre!**

Para essa análise de dados, nossa variável resposta é a produção (`prod`) e a repetição (`rep`), a progênie (`prog`) e a colheita (`colheita`) serão fatores no nosso modelo, identificados por seus níveis.

```{r}
# Transformar em fator
data$rep <- as.factor(data$rep)
data$prog <- as.factor(data$prog)
data$colheita <- as.factor(data$colheita)
str(data)

# Outra opção
data <- transform(data, rep = factor(rep), prog = factor(prog), colheita = factor(colheita))
str(data)
```

Vamos analisar somente os dados referentes à primeira colheita. Para isso, podemos obter o subconjunto referente a ela:

```{r}
# Indexar primeita colheita
Colheita_1 <- subset(data, colheita == 1)
str(Colheita_1)
```

Repare que, ao fazer o subconjunto, os três níveis do fator colheita ainda são mantidos, embora agora tenhamos apenas um. Isso pode ser um problema para a nossa análise. Portanto, devemos remover os níveis excedentes:

```{r}
# Droplevels
Colheita_1 <- droplevels(subset(data, colheita == 1))
str(Colheita_1)
```

Em seguida, podemos rodar nosso modelo de análise de variância.

```{r}
# Modelo
Modelo1 <- aov(prod ~ rep + prog,
               contrasts = list(prog = "contr.sum"), 
               data = Colheita_1)
anova(Modelo1)
```

Essa análise variância exige alguns pressupostos, podemos verificar eles nos nossos dados usando:

```{r}
####################################################
###verificar Pressupostos da análise de variância###
####################################################
names(Modelo1)
Modelo1_residuals <- Modelo1$residuals #armazenando os erros ou resíduos

# teste de Normalidade DOS ERROS##
#---------------------------------#
shapiro.test (Modelo1_residuals) # Hipótese de Nulidade
# a hipótese de que os erros são normais, nesse caso, como o p-value = 0.24
# ou seja, é maior que >0.05 ou 0.01 (alfa adotado), não se rejeita a hipotese de normalidade 
```

Vamos trabalhar um poquinho com as informações da ANOVA? Primeiro, guardaremos o valor do quadrado médio:

```{r, eval=TRUE}
QME <- anova(Modelo1)["Residuals", "Mean Sq"]
QME
```

E a média da primeira colheita da nossa variável resposta (produção):

```{r, eval=TRUE}
med <- mean(Colheita_1$prod, na.rm = TRUE)
med
```

Com eles podemos calcular o coeficiente de variação (CV):

```{r, eval=TRUE}
CVe <- (sqrt(QME)/med)*100
CVe
```

> Calcule o CVe e QME para a colheita 2

> Crie uma função calcular o CVe

Possibilidade de respostas:

```{r, eval=TRUE}
CV_E <- function(anova, med){
  QME <- anova(anova)["Residuals", "Mean Sq"]
  CVe <- (sqrt(QME)/med)*100
  
  return(CVe)
}

## 
CV_E(anova = Modelo1, med = med)
```

Podemos também calcular a herdabilidade da característica produção:

```{r, eval=TRUE}
n_rep <- nlevels(Colheita_1$rep)
VG <- (anova(Modelo1)["prog", "Mean Sq"]- QME)/n_rep
VE <- QME
H_2 <- VG/ (VG + VE)
H_2
```

> Crie uma função para estimar a herdabilidade 

## Criando mapas com ggplot

Não vamos entrar em detalhe sobre os códigos que usamos aqui porque ele faz uso do `tidyverse`, um pacote que permite manipular os dados com muita flexibilidade, mas ele iria requerer outro curso focado apenas nele! Esta é uma aplicação para mostrar que conseguimos fazer quase tudo com R e ggplot em mãos. O mais difícil é saber manipular os dados...

```{r}
### Instalar pacotes ###
# devtools::install_github("rpradosiqueira/brazilmaps")
# Need to install 'sf' 
# install.packages("sf")
#  and also the dependencies:
# - 'units' (libudunits2-dev - Linux)
# - 'gdal' (libgdal-dev - Linux)
#
#######################

# Carregar pacote
library(tidyverse)
library(sf)

# Caso não tenha mais conjunto dados disponível no seu ambiente de trabalho
dados = read.csv("dados_alunos2021.csv", stringsAsFactors = FALSE, dec = ",")

# ou
load("dados_alunos2021.RData")

colnames(dados) = c("Ocupacao", "Graduacao", "Conhecimentos_Genetica", "Conhecimentos_Estatistica", "Conhecimento_Gen_Est", 
                   "Latitude", "Longitude")

# Coletando os dados da base por estado
estados = brazilmaps::get_brmap("State")

# Adicionando uma coluna com as siglas dos estados, será importane para a próxima etapa
estados$sigla = c("RO", "AC", "AM", "RR", "PA", "AP", "TO", "MA", "PI", "CE", "RN", "PB", "PE", "AL", "SE", "BA", "MG", "ES", "RJ", "SP", "PR", "SC", "MS", "MT", "GO", "DF", "RS")

## Aqui buscaremos se as coordenadas das cidades estão contidas nas coordenadas 
## dos estados
inter_sf = st_as_sf(dados, coords = c('Longitude', 'Latitude'), crs = st_crs(estados))

## Mapear coordenadas das cidades nos estados
map_data = st_join(inter_sf, estados %>% 
                     select(sigla, geometry) %>% 
                     mutate(geom_state=geometry)) %>%
  as.data.frame() %>% 
  select(sigla, geom_state)
  
# Verificar quantas pessoas por estado 
# Juntar com poligonos dos estados
to_plot = map_data %>%
  group_by(sigla) %>%
  summarise(n = n()) %>%
  right_join(., estados, by=c("sigla"))

# Aqui usamos um outro tipo de plot, o geom_sf(), que precisa de dados de
# coordenadas geométricas para construir os mapas. O resto envolve apenas
# funções e argumentos do ggplot!
ggplot(to_plot) +
  geom_sf(aes(geometry = geometry, fill = n)) + 
  theme_minimal() + scale_fill_continuous(low = "#C6FFDD", high = "#f64f59", na.value="white") +
  labs(fill = "Número \nde pessoas")
```

Que tal tentarmos fazer com o mapa mundi?

```{r}
# Pacotes

# install.packages("rnaturalearth")
# install.packages("rnaturalearthdata")
# install.packages("rgeos")

library("rnaturalearth")
library("rnaturalearthdata")
library("rgeos")

# Mapa mundial
world <- ne_countries(scale = "medium", returnclass = "sf")

## Buscaremos se as coordenadas das cidades estão contidas nas coordenadas 
## dos paises
inter_sf = st_as_sf(dados, coords = c('Longitude', 'Latitude'), crs = st_crs(world))

map_data = st_join(world, inter_sf) %>%
  filter(!is.na(Graduacao)) %>% 
  select(name, geometry) %>% 
  as.data.frame()


# Verificar quantas pessoas por país 
# Juntar com poligonos dos países
to_plot = map_data %>%
  group_by(name) %>%
  summarise(n = n()) %>%
  right_join(., world, by=c("name"))

# Aqui usamos um outro tipo de plot, o geom_sf(), que precisa de dados de
# coordenadas geométricas para construir os mapas. O resto envolve apenas
# funções e argumentos do ggplot!
ggplot(to_plot) +
  geom_sf(aes(geometry = geometry, fill = n)) + 
  theme_minimal() + scale_fill_continuous(low = "#C6FFDD", high = "#f64f59", na.value="white") +
  labs(fill = "Número \nde pessoas")
```

## Família de funções `apply`

A família de funções `apply` também podem funcionar como um estrutura de repetição. Sua sintaxe é mais enxuta quando comparada com `for` ou `while` e pode facilitar a elaboração do código. 

Aqui vamos exemplificar o uso de algumas dessas funções.

### apply

A função `apply` é a base de todas as outras funções da família, portanto a compreensão do funcionamento desta é essencial para entender as demais. Se buscar no help da função, ele indicará que os argumentos da função consistem em: apply(X, MARGIN, FUN, ...). Sendo X o conjunto de dados em formato de array (incluindo matrix, que consiste num array de dimensão 2), MARGIN será 1 se a ação deverá ser aplicada à linhas, 2 se for aplicada a colunas e c(1,2) se for aplicada a ambas; FUN é a função que indica ação.

Num simples exemplo temos a matrix:

```{r}
ex_mat <- matrix(seq(0,21,3), nrow = 2)
```

Se quisermos somar os elementos das colunas usamos:

```{r}
apply(ex_mat, 2, sum)
```

Se quisermos somar os elementos das linhas:

```{r}
apply(ex_mat, 1, sum)
```

Se fossemos utilizar o `for` para realizar essa tarefa:

```{r}

# Soma das colunas
for(i in 1:dim(ex_mat)[2]){
  print(sum(ex_mat[,i]))
}

# Soma das linhas
for(i in 1:dim(ex_mat)[1]){
  print(sum(ex_mat[i,]))
}
```

### lapply

Se diferencia do `apply` por poder receber outros tipos de objetos (mais utilizado com listas) e devolver o resultado  em uma lista.


```{r}
ex_list <- list(A=matrix(seq(0,21,3), nrow = 2), 
                B=matrix(seq(0,14,2), nrow = 2), 
                C= matrix(seq(0,39,5), nrow = 2))
str(ex_list)
```

Para selecionar a segunda coluna de todas as matrizes

```{r}
lapply(ex_list, "[", 2)
```

### sapply

A função `sapply` funciona como o `lapply` a diferença é que ele retorna apenas um valor por componente da lista e os deposita em um vetor de resposta. Como no exemplo:

```{r}
sapply(ex_list, "[",1,3)
```

### tapply

Esta função é um pouco diferente das demais, ela exige que exista alguma variável categórica (fator) para aplicar ação separadamente conforme suas categorias (levels). Por isso, normalmente é aplicada a data.frames.

Vamos utilizar nosso conjunto de dados:

```{r}
str(dados)
dados$Graduacao  <- as.factor(dados$Graduacao)

dados[dados == "Avançado"] <- 3
dados[dados == "Intermediário"] <- 2
dados[dados == "Básico"] <- 1
dados[dados == "Sabe o teste F? Fui eu que desenvolvi, mas não publiquei porque sou modesto"] <- 99

dados$Conhecimentos_Genetica <- as.numeric(dados$Conhecimentos_Genetica)

tapply(dados$Conhecimentos_Genetica, dados$Graduacao, mean)
```

Saiba mais sobre essa família de funções no [link](https://www.r-bloggers.com/r-tutorial-on-the-apply-family-of-functions/)

Observe que nas funções `apply` podemos trocar as funções prontas do *r base* por funções personalizadas. 

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão extra**](exercicios.html), se não, faça-os no conforto do seu lar e nos envie dúvidas pelo fórum.


## Gerando sorteio para delineamento experimental

Que tal pensarmos em um delineamento experimental e sortearmos as unidades experimentais? Com o pacote `agricolae` elaboraremos o sorteio de um experimento de blocos completos casualizados.

```{r,  message=FALSE, warning=FALSE}
############################
#SORTEIO DE EXPERIMENTOS####
############################

#install.packages("agricolae")
library(agricolae)
trt <- c("0","1","2","5","10","20","50","100","Dina")
rcbd <- design.rcbd(trt, 6, serie = 1, seed = 1, "default") # seed = 1
rcbd # Planilha de campo
```

Podemos exportar e salvar nosso sorteio com:

```{r}
write.table(rcbd,"SORTEIO.txt", row.names=FALSE, sep="\t")
file.show("SORTEIO.txt")
write.csv(rcbd,"SORTEIO.csv",row.names=F)
```

## PCA - Análise de componentes principais

O PCA é uma análise exploratória muito frequente quando utilizada por usuários que possuem muitos dados. Nela, torna-se possível visualizar dados que deveriam ter diversas dimensões em apenas duas componentes mais informativas. Para isto, usamos a função `autoplot()`.

```{r, eval=FALSE}
# para instalar, use install.packages("ggfortify")
library(ggfortify)

autoplot(prcomp(~ conhecimentoR + altura + peso + idade, data = dados),
         data = dados, shape = 'area', colour = 'Graduacao', loadings = TRUE, loadings.colour = 'red', 
         loadings.label = TRUE, loadings.label.colour = 'black',
         loadings.label.size = 4) +
  labs(shape = "Área de \ninteresse", color = "Formação", title = "PCA")

# Os parâmetros relacionados com "LOADINGS" são na verdade a direção onde a váriável mais cresce em duas dimensões
# Ela serve apenas como uma aproximação, já que os dados reais precisariam de mais dimensões, que nosso olho não pode ver
```

Agora que você fez um plot de PCA, você pode perceber que ele é apenas uma variação do `geom_point()`, isto permite que você adicione todas as camadas de ggplot que você quiser sobre este gráfico. Já fizemos isto com as legendas!


# Sugestões, críticas e elogios

Caso tenha sugestões para aprimoramento desse material, enviar e-mail para `biometriamarcadores@gmail.com`.

Acesse também outros materiais em português produzidos pela mesma equipe [aqui](http://cristianetaniguti.github.io/Workshop_genetica_esalq/).

Este material foi produzido por alunos do programa de pós-graduação em Genética e Melhoramento de Plantas. Cristiane Taniguti, Fernando Correr e e Wellingson Araújo ministraram o Treinamento.

Também recomendamos materiais em inglês [aqui](https://GENt-esalq.github.io/cursoR/english_tutorials.html).
